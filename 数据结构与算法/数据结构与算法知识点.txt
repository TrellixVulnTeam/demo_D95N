数据结构与算法是一种思路

数据类型：数组，集合，字典

线性结构链表：arraylist和linkedlist 

***数组，栈和队列，链表是一种线性结构，
链表查找效率是非常低的，因为它是线性操作。
但是通过数组取元素性能非常高，直接通过下标index获取就行

栈结构： 容器中，先进后出，后进先出，添加元素是在栈顶操作的，只能在一端添加。
向栈插入元素又称为 进栈，入栈，压栈
删除元素： 出栈 退栈
进：1->2->3   出：3->2->1



队列： 先进先出，只允许一端插入，通常 开启多哥线程。
队列两种实现方案： 数组，链表（基于链表的话，性能更高一些）

优先级队列： 保证该元素的优先级顺序，获取正确的位置。

数组结构：存储多个元素，连续的内存空间，不能满足容量需求时，需要扩容。
        通过数组取元素性能非常高，直接通过下标index获取就行
        缺点：插入和删除效率比较低
        优点：基于索引查找效率高。
链表结构：存储多个元素，不必连续的内存空间，下一个元素的引用。
        优点：内存可动态管理，插入和删除数据，时间复杂度O(1),效率高很多。
        缺点：都需要从头开始方案，无法跳过第一个元素访问任何一个元素，
             链表查找效率是非常低的，因为它是线性操作

**什么时候选择数组，什么时候选择链表： 当查找元素使用数组，当插入和删除元素使用链表。

单向链表：只能从头遍历到尾或者从尾遍历到头，上一个链表中有一个指向下一个的引用。
        缺点：下一个节点简单，上一个节点难。（如：文本编辑器的光标）

双向链表：既可以从头遍历到尾，也可以从尾遍历到头，双向的。
        一个节点可以向前连接，也可以向后连接引用。
        缺点：插入和删除某个节点，需要处理四个引用，单向链表只需要两个引用，实现起来困难。

总结，单向链表和双向链表选择？ 实际开发中双向链表使用频率多。


集合：哈希表封装，无序的，不能重复的元素构成，不允许重复的。Object Set类就是集合类。
     特殊的数组：没有顺序，也不能重复

并集： A和B的并集，返回一个包含两个集合中（所有）元素的新集合
交集： A和B的交集，返回一个包含两个集合中（共有）元素的新元素。
差集： A和B的差集，返回一个包含所有存在于第一个集合A且不存在于第二个集合B的元素的新集合。
子集： A和B的子集，返回验证一个给定集合是否是另一个集合的子集。

字典：也是数据类型
     字典中的key值是不可以重复的，而value是可以重复的，并且字典中key是无序的。

哈希表：基于数组进行实现的，但是相对于数组，它有很多
   优点：高效插入，删除   无论多少数据，都是O(1)的时间复杂度，只需要几个机器指令即可完成
        哈希表查找比树还要快，能瞬间查找到想要的元素。
        哈希表对于树来说编码要容易。
   缺点： 没有顺序，无序的，key 不能是重复的。

   哈希表是将目标值通过哈希函数转换为下标值，再对于下标值进行查找。
   下标值（其实就是字母/文字/数字/ASCII编）

   ASCII编码: a:97  b:98~z:122  A:65 B:66~Z:90

   字母转数字：
        方案1: 幂的连乘，数字唯一性
        方案2: 转换为链表地址法查找，通常会使用线性查找。

   开放地址法：主要工作方式是寻找空白的单元格，三种方式：
            线性探测：线性的查找空白的单元。一次探测一个步长，查到空位置，就停止，再从index+1的位置查找下一个。
                    缺点：会产生聚集，一连串填充单元。
            二次探测：主要优化了探测时的步长，一次探测多步 x+1立方 x+2立方，避免产生聚集
                    缺点：步长不一的一种聚集，步长隔着很远。
            再哈希法：吧关键字用另外一个哈希函数，再做一次哈希化，用这次哈希化的结果作为步长（递归）。

   哈希化：插入和搜索效率非常高。arraySize数据项。
   优化哈希函数： 尽量少的乘法和除法
                快速的计算： hashcode 
                均匀分布：幂的连乘
                幂的底数最好用质数
   hashmap：初始长度是16，每次自动扩展，长度必须是2的幂次，采用了位运算。
            
   哈希表扩容：链地址法，loadFactor可以大于1，随着数量增多，造成效率降低，需要在合适的时候进行扩容。

质数：也称为素数。只能被1和自己整除的数

树结构：拥有子节点，顶点，查找方案，广度查找和深度查找规则。
        优点：二分查找时间复杂度是 O(logN)

二叉树：如果树种每个节点最多只能有两个子节点，称之为二叉树。
       特性：2^(i-1) i>=1;
            2^k-1,k>=1;

二叉搜索树： 二叉排序树或者二叉查找树，
          二叉树的遍历有三种方式：
                先序遍历：1.先访问根节点；2.左子树；3，右子树-->根，左，右
                中序遍历：1.先访问左子树；2。根节点；3，右子树-->左，根，右   可以实现正序排序
                后序遍历：1.先左子树；2.右子树；3.根节点
        
        最小值：左子节点，最底层的
        最大值：右子节点，最底层的

二叉搜索树的缺陷:如果插入的数据是(有序数据)，那么左边的树可能非常长。深度非常深，也就是非平衡树。
              

平衡二叉树：比较好的二叉树，左右均匀分布的树叫平衡树，深度不会很深。
        包含： AVL树： O（logN）次，每次插入/删除操作相对红黑树效率不高。整体效率不如红黑树
              红黑树：O（logN）次，根节点是红色节点，子节点是红色或者黑色节点，
                    插入的节点是红色节点
                    旋转：左旋转：逆时针，使得父节点被自己的右孩子取代，自己成为左孩子。
                         右旋转：使得父节点被自己的左孩子取代，自己成为右孩子。
                    变色：为了符合规则，红色节点变为黑色，或黑色变红色。
               插入：


图： 图论的由来，是欧拉七桥故事
   用数字更容易我们从整体来观察整个图结构。

   顶点：图中的一个节点。
   边：两个站点之间的直接连线，就是一个边
   相邻顶点：由一条边连接在一起的顶点称为相邻顶点。
   度： 一个顶点的度是相邻顶点的数量。
   路径：顶点v1,v2...,vn
   无向图：所有的边都没有方向。
   有向图：图中的边是有方向的

邻接表：入度，出度，逆邻接表，出度相对用的比较少。

图的遍历思想：将图中每个顶点访问一遍，并且不能有重复的访问。
           两种思路：广度优先搜索（Breadth-First Search,简称BFS），每个节点每个路线都扫描一遍。
                        基于队列，入队列的顶点先被探索。
                    实现：创建一个队列q；
                        将v从Q中取出队列；
                        将V标注为被发现的灰色。 
                        将v标志为黑色。
                   深度优先搜索（Depth-First Search,简称DFS），一黑到底，一条线路走到底，没有回路
                        基于栈或使用递归，通过将顶点存入栈中，顶点是沿着路径被探索。存在相邻顶点就去访问。
                都需要明确指定第一个被访问的顶点。


认识大O表示法： 粗略的度量被称作“大O”表示法

        O(1) 常数
        O(log(n)) 对数
        O(nlog(n)) 线性和对数乘积
        O(n2)  平方
        O(2n)  指数的
        O(n)   线性的

排序算法：
        简单排序：冒泡排序-选择排序-插入排序
        高级排序：希尔排序-快速排序

        冒泡排序：时间复杂度 O(n2)   （n-1）+（n-2）+（n-3）+（n-4）  = （n2）
                从头到尾依次比较相邻的两个元素的大小，如果当前元素大于下一个元素，那么交换位置
                第一次：i=length-1,比较到倒数第一个位置
                第二次：i=length-2，比较倒数第二个位置
        选择排序：时间复杂度 O(n2)   （n-1）+（n-2）+（n-3）+（n-4）  = （n2）
                将交换的次数由o(n2)减少到O(n);
                思路：选定第一个索引位置，然后和后面元素依次比较，依次往后找，找到(最小)的，
                     如果找到的值小于第一个索引，交换位置。
                     第二次将第二小的值进行交换。
        插入排序：时间复杂度 O(n)
                局部有序，将交换的次数由o(n2)减少到O(n)，这个被标记的队员左边的所有队员已经是局部有序的。
               思路：逐个查找元素，与前面的元素作对比，依次平移，插入到前面i-1合适的位置。
        
        希尔排序:时间复杂度 O(N^7/6),最坏的复杂度 O(N^4/3)   ^ 表示开方
               思路：设置间隔值，初始间隔值n/2，进行分组，在当前组内进行排序，（35，81），（94，17），（11，95）；
                   依次再设置更小的间隔值，进行分组，再进行组内排序。
        快速排序：最快的一种算法排序，时间复杂度   O(n*logn)
               思路：核心思想，分而治之，
                    第一步：从数组中任意取出一个数组，比它小的放在左边，比他大的放在右边。
                    第二步：递归处理，左边取出一个数据，右边取出一个数据，最终完成排序
                

